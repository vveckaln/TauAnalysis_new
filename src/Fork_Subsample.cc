#include "LIP/TauAnalysis/interface/Fork_Subsample.hh"#include "LIP/TauAnalysis/interface/GlobalVariables.hh"#include "LIP/TauAnalysis/interface/Parser.hh"#include "LIP/TauAnalysis/interface/Register.hh"#include "LIP/TauAnalysis/interface/HStructure_worker.hh"#include <math.h>#include "TCanvas.h"using namespace cpregister;using namespace gVariables;Fork_Subsample::Fork_Subsample(EventSink<event_type> *next_processor_stage):EventProcessor<event_type, event_type>(next_processor_stage){    if (IsGeneric) SetEnvironment_generic();  if (IsDY) SetEnvironment_DY();  if (IstW) SetEnvironment_TTbarMC();  if (IsTTbarMC) SetEnvironment_TTbarMC();  received = 0;   passed = 0;}void Fork_Subsample::Run(){  received ++;  ngen_electron_status3 = 0;  ngen_muon_status3 = 0;  ngen_tau_status3 = 0;  for(size_t ig = 0; ig < input_event -> gen.size(); ig++)    {      if(input_event -> gen[ig].status() != 3) continue;      int id(abs(input_event -> gen[ig].pdgId()));          if(id==11) ngen_electron_status3++;      if(id==13) ngen_muon_status3++;      if(id==15) ngen_tau_status3++;    }    printf("status3 electrons %u muons %u taus %u\n", ngen_electron_status3, ngen_muon_status3, ngen_tau_status3);  for (number_active_sample = 0; number_active_sample < *number_of_samples; number_active_sample ++)    {      ReadEvent_llvv event;      if (number_active_sample < *number_of_samples - 1)	{	  event = *input_event;	  output_event = &event;	}      else	output_event = input_event;            bool sample_valid = (this ->* sample_check_ptr[number_active_sample])();;      if (not sample_valid)	continue;  /*printf("EVENT IDENTITY %u %u %u\n", processed_event -> Run, processed_event -> Lumi, processed_event -> Event);    processed_event -> ls("electron", "verbose");    processed_event -> ls("muon", "verbose");    printf("Event passed quality cleaning       %s\n", PassedCleaning ? "true" : "false");    printf("Leading lepton is a muon            %s\n", LeptonCorresponds ? "true" : "false");    printf("Muon trigger fired                  %s\n", Trigger_Fired ? "true" : "false");    printf("Event was selected for muon channel %s\n", channel_opened ? "true" : "false");    printf("---------------- NEXT -----------------------\n");*/            passed ++;      printf("proceeding %s\n", samples_names[number_active_sample].Data());      ProceedToNextStage();    }  printf("--------------\n");}bool Fork_Subsample::CheckTTbarMC_muon_tau() const{      if(ngen_tau_status3 == 1      and ngen_muon_status3 == 1      and ngen_electron_status3 == 0)    return true;  else return false;}bool Fork_Subsample::CheckTTbarMC_lepton_jets() const{  if(ngen_tau_status3 == 0     and (ngen_muon_status3 + 	  ngen_electron_status3) >= 1)     return true;  else return false;}bool Fork_Subsample::CheckTTbarMC_dilepton_muon_electron() const{  if(ngen_tau_status3 == 0     and ngen_muon_status3 >= 1     and ngen_electron_status3 >= 1)     return true;  else return false;}bool Fork_Subsample::CheckTTbarMC_dilepton_muon_muon() const{  if(ngen_tau_status3 == 0     and ngen_muon_status3 >= 2     and ngen_electron_status3 == 0)     return true;  else return false;}bool Fork_Subsample::CheckTTbarMC_tau_jets() const{  if(ngen_tau_status3 == 1     and ngen_muon_status3 == 0     and ngen_electron_status3 == 0)    return true;  else return false;}bool Fork_Subsample::CheckTTbarMC_tau_tau() const{  if(ngen_tau_status3 == 2     and ngen_muon_status3 == 0     and ngen_electron_status3 == 0)     return true;  else return false;}bool Fork_Subsample::CheckTTbarMC_hadronic() const{  if(ngen_tau_status3 == 0     and ngen_muon_status3 == 0     and ngen_electron_status3 == 0)     return true;  else return false;}bool Fork_Subsample::CheckDY_lepton_lepton() const{  if(ngen_tau_status3 == 0      and (ngen_muon_status3 + 	  ngen_electron_status3) == 2)     return true;  else return false;}bool Fork_Subsample::CheckDY_tau_tau() const{  if(ngen_tau_status3 == 2      and ngen_muon_status3 == 0      and ngen_electron_status3 == 0)     return true;  else return false;}void Fork_Subsample::SetEnvironment_TTbarMC() {  typedef bool (Fork_Subsample::*type_ptr)() const;  sample_check_ptr = new type_ptr[*number_of_samples];  type_ptr fnc_ptr[] =     {      &Fork_Subsample::CheckTTbarMC_muon_tau,       &Fork_Subsample::CheckTTbarMC_lepton_jets,       &Fork_Subsample::CheckTTbarMC_dilepton_muon_electron,       &Fork_Subsample::CheckTTbarMC_dilepton_muon_muon,      &Fork_Subsample::CheckTTbarMC_tau_jets,      &Fork_Subsample::CheckTTbarMC_tau_tau,      &Fork_Subsample::CheckTTbarMC_hadronic,     };  for (unsigned short fnc_ind = 0; fnc_ind < *number_of_samples; fnc_ind++)    {      sample_check_ptr[fnc_ind] = fnc_ptr[fnc_ind];    }}void Fork_Subsample::SetEnvironment_DY() {  typedef bool (Fork_Subsample::*type_ptr)() const;  sample_check_ptr = new type_ptr[*number_of_samples];  type_ptr fnc_ptr[] =     {      &Fork_Subsample::CheckDY_lepton_lepton,       &Fork_Subsample::CheckDY_tau_tau         };  for (unsigned short fnc_ind = 0; fnc_ind < *number_of_samples; fnc_ind++)    {      sample_check_ptr[fnc_ind] = fnc_ptr[fnc_ind];    }}void Fork_Subsample::SetEnvironment_generic() {  typedef bool (Fork_Subsample::*type_ptr)() const;  sample_check_ptr = new type_ptr[*number_of_samples];  type_ptr fnc_ptr[] =     {      &Fork_Subsample::CheckGeneric     };  for (unsigned short fnc_ind = 0; fnc_ind < *number_of_samples; fnc_ind++)    {      sample_check_ptr[fnc_ind] = fnc_ptr[fnc_ind];    }}bool Fork_Subsample::CheckGeneric() const{  return true;}/*TH1D * const Fork_Subsample::GetStatisticsHistogram(const unsigned short sample_ind) const{   return (TH1D*)hstruct_worker -> GetHStructure(samples_names[sample_ind], "numb_events_selection_stagesCHANNELGATE") -> GetPtr();   }void Fork_Subsample::CollectStatistics(){    TH1D * const h = GetStatisticsHistogram(number_active_sample);   const double weight = 1;  h -> Fill(Fork_Subsample_report_Xaxis_labels[0], weight);  if (PassedCleaning)    h -> Fill(Fork_Subsample_report_Xaxis_labels[1], weight); else return;  if (LeptonCorresponds)    h -> Fill(Fork_Subsample_report_Xaxis_labels[2], weight); else return;  if (Trigger_Fired)    h -> Fill(Fork_Subsample_report_Xaxis_labels[3], weight); else return;  if (not OtherTriggersVeto)    h -> Fill(Fork_Subsample_report_Xaxis_labels[4], weight); else return;  if (valid_TTbarMC)    {                  h -> Fill(Fork_Subsample_report_Xaxis_labels[5], weight);           }       }*/void Fork_Subsample::Report(){    printf("Fork subsample received %f passed %f\n", received, passed);  ContinueReportToNextStage();}Fork_Subsample::~Fork_Subsample(){}